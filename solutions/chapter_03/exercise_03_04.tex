\section{}
\label{section: LU decomposition}

Wir schreiben zunächst eine Klasse \texttt{Rational}, die ein genaues Rechnen mit rationalen Zahlen erlaubt.

\lstinputlisting[style=pythoncode]{chapter_03/rationals.py}

Die LU-Zerlegung von passenden Matrix mit ganzzahligen Einträgen kann nun dem folgenden naiven Algorithmus berechnet werden:

\lstinputlisting[style=pythoncode, firstline = 3, lastline = 21]{chapter_03/exercise_03_04.py}

Wir testen das Program anhand der gegebenen Matrizen
\[
    A
    = \begin{pmatrix}
        3 &  2 & 1  \\
        6 &  6 & 3  \\
        9 & 10 & 6
      \end{pmatrix}
    \quad\text{und}\quad
    B
    = \begin{pmatrix}
        0 & 1 \\
        1 & 0
      \end{pmatrix}
\]
mit dem folgenden Code:

\lstinputlisting[style=pythoncode, linerange={23-26,32-40,52-56,61-63}]{chapter_03/exercise_03_04.py}

Wir erhalten den folgenden Output:

\begin{consoleoutput}
A:
[3 2  1]
[6 6  3]
[9 10 6]
L:
[9/9  0/18  0]
[18/9 18/18 0]
[27/9 36/18 1]
U:
[3/1   2/1   1/1    ]
[0/3   6/3   3/3    ]
[0/162 0/162 162/162]
Check if L*U == A:
True
B:
[0 1]
[1 0]
Trying to calculate the LU decomposition of B:
Traceback (most recent call last):
  File "exercise_03_04.py", line 69, in <module>
    (L,U) == naive_lu(B)
  File "exercise_03_04.py", line 17, in naive_lu
    raise ValueError("algorithm does not work for this matrix")
ValueError: algorithm does not work for this matrix
\end{consoleoutput}

Da die Matrix $B$ keine LU-Zerlegung besitzt, ist es okay, dass unser Algorithmus diese nicht findet.
