\section{}
\label{section: LU decomposition}

Wir schreiben zunächst eine Klasse \texttt{Rational}, die ein genaues Rechnen mit rationalen Zahlen erlaubt.

\lstinputlisting[style=pythoncode, firstline = 3, lastline = 43]{chapter_03/exercise_03_04.py}

Wir erweitern nun die bisherige \texttt{Matrix}-Klasse um weitere Methoden.
(Aus Platzgründen kopieren wir den bereits vorhandenen Code nicht noch einmal.)

\lstinputlisting[style=pythoncode, firstline = 110, lastline = 123]{chapter_03/exercise_03_04.py}

Wir nutzen im Folgenden auch einige Hilfsfunktionen, um den Umgang mit Matrizen zu erleichtern.
(Dies sind keine zusätzlichen Methoden der Klasse \texttt{Matrix}.)

\lstinputlisting[style=pythoncode, firstline = 129, lastline = 146]{chapter_03/exercise_03_04.py}

Die LU-Zerlegung von passenden Matrix mit ganzzahligen Einträgen kann nun dem folgenden naiven Algorithmus berechnet werden:

\lstinputlisting[style=pythoncode, firstline = 152, lastline = 167]{chapter_03/exercise_03_04.py}

Für die gegebene Matrix
\[
    A
    = \begin{pmatrix}
        3 &  2 & 1  \\
        6 &  6 & 3  \\
        9 & 10 & 6
      \end{pmatrix}
\]
erhalten wir das folgende Ergebnis:
\begin{consoleoutput}
>>> A = Matrix([[3,2,1],[6,6,3],[9,10,6]])
>>> (L,U) = naive_lu(A)
>>> print(L)
[9/9  0/18  0/1]
[18/9 18/18 0/1]
[27/9 36/18 1/1]
>>> print(U)
[3/1   2/1   1/1    ]
[0/3   6/3   3/3    ]
[0/162 0/162 162/162]
>>> print( (L*U).mapentries(float) )
[3.0 2.0  1.0]
[6.0 6.0  3.0]
[9.0 10.0 6.0]
\end{consoleoutput}
Für die gegebene Matrix
\[
    B
    = \begin{pmatrix}
        0 & 1 \\
        1 & 0
      \end{pmatrix}
\]
(welche keine LU-Zerlegung besitzt) bricht das Programm mit einem Fehler ab.
\begin{consoleoutput}
>>> B = Matrix([[0,1],[1,0]])
>>> (L,U) == naive_lu(B)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 12, in naive_lu
ValueError: algorithm does not work for this matrix
\end{consoleoutput}
